#include <iostream>
using namespace std;
int max_1[301]; // oo 
int max_2[301]; // xo
int main(){
    int n;
    cin >>n;
    int score;
    cin >>score;
    if(n==1) {cout<<score;return 0;}
    max_1[1]=score;
    max_2[1]=score;
    cin >>score;
    max_1[2]=max_1[1]+score;
    max_2[2]=score;
    if(n==2) {cout<<max_1[2];return 0;}
    for(int i=3;i<=n;i++){
        cin >>score;
        max_2[i]=max(max_1[i-2],max_2[i-2])+score;
        max_1[i]=max_2[i-1]+score;
    }
    
    cout<<max(max_2[n],max_1[n]);
}

# 이동인 - BOJ_2579
### 설계
#### DP로 푸는 이유
128MB = (2^7)*(2*10)*(2*10)/(2^2) = 2^25개 로 약 32,000,000개의 정수 저장 가능 => DP로 풀기 넉넉
1초 = 약 1억인데, O(n-2)+O(n-1)=O(n)의 구조라 시간복잡도가 피보나치와 유사하고 재귀 콜을 사용하면 약 O(n) = 2^n 이고, n = 300이기 때문에, O(n) = 2^300 = (1000)^30 ,,, wow 무조건 터진다.
반면에 n = 1부터 순차적으로(선형적으로) 저장해 나가면 O(n) = n이기 때문에 괜찮음.
 
#### 저장 방법
n번째 계단을 밟을 때 score의 최댓값을 O(n)이라고 하자. (DP로 풀건데 재귀 함수처럼 함수로 정의하는 이유는 내가 이걸 생각하기에 재귀함수가 더 자연스럽게 떠올릴 수 있어서다. 이후에 문제 풀 때는 max[n]으로 바꿀 것임)
O(n)은 두 가지 방법으로 더 작은 n1의 함수값으로 바꿀 수 있다.
동주가 n번 째 계단을 밟을 때 O(n)이라는 최댓값의 점수를 얻었다먄, 이 때 동주는 이전 계단을 밟았거나 밟지 않았을 것이다. 따라서 임의의 자연수 n (n>=2)에대해서, n번째 계단은 밟았고 n-1번째 계단도 밟았을 떄 최댓값을 O1(n)이라고 하고, n번 째 계단은 밟았지만 n-1번째 계단을 밟지 않았을 때 최댓값을 O2(n)라고 하면,
```
O(n) =(0)= max(O1(n),O2(n)) =(1)= max((O1(n-1)+(n번쨰 계단 score)), O2(n-2)+ (n번째 계단 score)) =(2)= max(O1(n-1), O2(n-2)) + (n번째 계단 score)
```
이다.

##### 이유
###### (0)
n번 째 계단을 밟았다면 n-1번째를 안밟았을 때와 n-1번째 계단을 밟았을 때 두 가지 경우로 나누어지고,
따라서, 
```
O(n) = max(O1(n),O2(n))
```
###### (1)
O1(n)은 O1이라는 함수의 정의에 따라, n, n-1번 째 계단을 밟았을 때 최댓값을 의미한다. O1(n)은 n-1번쨰 계단을 밟았을 떄 최댓값에 n번 째 계단을 밟았을 떄 점수를 더한 것과 같으므로 
```
O1(n) = O1(n-1)+ (n번 째 계단 score)
``` 
이다. 

마찬가지로, O2(n)은 O1이라는 함수의 정의에 따라, n번 째 계단은 밟고 n-1번 째 계단을 밟지 않았을 때 최댓값을 의미한다. O2(n)은 n-2번쨰 계단을 밟았을 떄 최댓값에 n번 째 계단을 밟았을 떄 점수를 더한 것과 같으므로 
```
O1(n) = O2(n-1)+ (n번 째 계단 score)
``` 
###### (2)
max((O1(n-1)+(n번쨰 계단 score)), O2(n-2)+ (n번째 계단 score)) 은 첫 번 째 파라미터, 두 번 째 파라미터 중 어느것이 크던 간에 O1(n-1), O2(n-2) 중 큰 값에 (n번 째 계단 score)를 더한 것과 같으므로,
```
max((O1(n-1)+(n번쨰 계단 score)), O2(n-2)+ (n번째 계단 score)) = max(O1(n-1), O2(n-2))+ (n번째 계단 score)
```
이다. 
 

### 느낀점
#### 재귀와 DP
재귀와 DP는 사실 비슷한 원리를 갖고 있다. 재귀와 DP는 반복되는 연산을 사전에 정의해서 재사용한다. 다만 재귀는 반복되는 연산 구조를 함수로 치환하고, DP는 반복되는 연산을 미리 값을 구해 저장하고 활용한다. 갖고 있는 시간과 메모리에 따라 적절히 선택해야 한다.
