# 이동인 - BOJ_12865
### 설계
#### 설계에서 어려웠던 점 1
어떤 물품이 포함되어있는지를 확인하면 안됐다.
포함되어있는 물품 id를 저장하면, 확인하는 과정에서 시간복잡도가 2^n = 2^100라 시간이 오래 걸린다.
#### 해결
그래서 임의의 id마다 'id보다 크지 않은 물품으로 구성된 배낭의 총 가치의 최댓값 (이하(val[id])'을 저장한다.
-> 이유 : id+1에 대해 val[id+1]을 저장할 때, val[id]를 구성하는 물품들 중에 id+1의 물품이 포함되어있지 않다는 것을 확신할 수 있어서 그렇다.

#### 설계에서 어려웠던 점 2
그냥 물품들의 가치 최대를 저장하면 안되는 이유는 무게 제한을 맞춰야하기 때문이다.
임의의 id에서 val[id]일 때 배낭을 구성하는 물품들의 총 무게가 현재 몇인지 모르고, 이후에 나올 id 초과의 물품의 무게를 모르기 때문에 무게 제한을 준수하는 아이디어가 필요하다.
#### 해결
(1) val[id]일 때 가능한 모든 무게의 경우의 수를 저장하기 -> 기각
val[id]일 때 가능한 모든 무게의 경우의 수를 저장하면 이후에 탐색하려면 또, id 하나당 탐색할 때 최대 2^id만큼 걸리기 때문에 총 시간은 최대 2^1 + 2^2 + ... 2^n 만큼 걸리기 때문에, 안좋음
(2) val[id]에서 아이디어를 추가하여, 임의의 물품 아이디 id와 무게 제한 w에 대해, id보다 크지 않은 물품으로 구성되어있으면서, 총 무게는 w 이하인 물품 구성의 가치 최댓값을 max_val[id][w]에 저장한다.

#### 종합
임의의 id(<=n)와 w(<=k)에 대해, max_val[id][w] 는 두 가지 방법으로 구할 수 있다.
최대 물품 아이디 상한이 id고, 총 무게 제한이 w인 물품 구성의 가치 최대는, 
아이디가 id인 물품이 포함되어있는 경우와 포함되어있지 않은 경우 중 더 가치가 큰 값을 채택하여 구할 수 있다.
따라서 max_val[id][w] = max(max_val[id-1][w-(max_val[id-1][w-(아이디가 id인 물품의 무게)])],max_val[id-1][w])이다.

### 시간복잡도와 공간복잡도
시간 복잡도는 최대 100*100,000 = 10,000,000 = 천 만 => 약 0.1초 <=2초
공간 복잡도는 최대 100*100,000*4(정수) = 약 2^26 <= 2^28 굳